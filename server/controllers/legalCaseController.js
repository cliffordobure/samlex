import LegalCase from "../models/LegalCase.js";
import CreditCase from "../models/CreditCase.js";
import User from "../models/User.js";
import Client from "../models/Client.js";
import Department from "../models/Department.js";
import Document from "../models/Document.js";
import mongoose from "mongoose";
import { createNotification } from "../services/notificationService.js";
import { getDepartmentForCase } from "../utils/departmentAssignment.js";

/**
 * @desc    Create a new legal case
 * @route   POST /api/legal-cases
 * @access  Private (legal_head, advocate)
 */
export const createLegalCase = async (req, res) => {
  try {
    console.log("=== DEBUG: createLegalCase ===");
    console.log("Request body:", JSON.stringify(req.body, null, 2));
    console.log("User:", req.user._id, req.user.role);
    console.log("User object:", JSON.stringify(req.user, null, 2));
    
    // Check if user has lawFirm
    if (!req.user.lawFirm) {
      console.log("❌ User has no lawFirm assigned");
      return res.status(400).json({
        success: false,
        message: "User is not associated with any law firm. Please contact your administrator.",
      });
    }
    
    console.log("Law Firm:", req.user.lawFirm._id);

    const {
      title,
      description,
      caseType,
      caseReference,
      assignedTo, // Add assignment field
      client,
      filingFee,
      courtDetails,
      opposingParty,
      dueDate,
      documents = [],
      escalatedFromCreditCase,
      requiredDocuments = [],
      escalatedFrom, // Add this for escalated cases
    } = req.body;

    // Check if user has permission to create cases
    if (!["legal_head", "advocate", "law_firm_admin"].includes(req.user.role)) {
      return res.status(403).json({
        success: false,
        message: "You don't have permission to create legal cases",
      });
    }

    // For escalated cases, we don't need a department
    const isEscalatedCase = escalatedFrom || escalatedFromCreditCase;

    // Get or create appropriate department for legal cases (skip for escalated cases)
    let legalDepartment = null;
    if (!isEscalatedCase) {
      try {
        legalDepartment = await getDepartmentForCase(req.user.lawFirm._id, 'legal', req.user.role);
        console.log("✅ Assigned to legal department:", legalDepartment.name, legalDepartment._id);
      } catch (error) {
        console.error("❌ Failed to assign legal department:", error.message);
        return res.status(500).json({
          success: false,
          message: "Failed to assign case to department. Please contact administrator.",
          error: error.message
        });
      }
    }

    // Handle client - if it's an object, create a new client user
    let clientId = client;
    if (client && typeof client === "object" && client.name && client.email) {
      // Check if client already exists
      let existingClient = await User.findOne({
        email: client.email,
        lawFirm: req.user.lawFirm._id,
        role: "client",
      });

      if (existingClient) {
        clientId = existingClient._id;
      } else {
        // Create new client user
        const [firstName, ...lastNameParts] = client.name.trim().split(" ");
        const lastName = lastNameParts.join(" ") || "Client";

        const newClient = new User({
          firstName: firstName || "Client",
          lastName: lastName,
          email: client.email,
          phoneNumber: client.phone || "",
          password: Math.random().toString(36).slice(-8), // Generate random password
          role: "client",
          lawFirm: req.user.lawFirm._id,
          createdBy: req.user._id,
        });

        const savedClient = await newClient.save();
        clientId = savedClient._id;
      }
    }

    // Process documents to add uploadedBy field
    const processedDocuments = documents.map((doc) => {
      if (typeof doc === "string") {
        // If it's a Cloudinary URL, create a document object
        const filename = doc.split("/").pop().split("?")[0] || "Document";
        return {
          name: filename,
          originalName: filename,
          path: doc, // Cloudinary URL
          size: 0, // Size not available for Cloudinary URLs
          mimeType: "application/octet-stream",
          uploadedBy: req.user._id,
        };
      } else {
        // If it's already a document object
        return {
          ...doc,
          uploadedBy: req.user._id,
        };
      }
    });

    // Case number will be generated by the model's pre-save hook

    const newCase = new LegalCase({
      title,
      description,
      caseType,
      caseReference,
      client: clientId,
      lawFirm: req.user.lawFirm._id,
      department: isEscalatedCase ? null : legalDepartment?._id, // No department for escalated cases
      filingFee,
      courtDetails,
      opposingParty,
      dueDate,
      documents: processedDocuments,
      createdBy: req.user._id,
      // Handle escalated cases
      escalatedFrom:
        escalatedFrom ||
        (isEscalatedCase
          ? { creditCaseId: escalatedFromCreditCase }
          : undefined),
      // Handle assignment - respect explicit assignment or auto-assign to advocate only if no assignment specified
      assignedTo:
        assignedTo ||
        (req.user.role === "advocate" && !assignedTo
          ? req.user._id
          : undefined),
      assignedBy:
        assignedTo ||
        (req.user.role === "advocate" && !assignedTo
          ? req.user._id
          : undefined),
      assignedAt:
        (assignedTo || (req.user.role === "advocate" && !assignedTo)) ? new Date() : undefined,
      // Set status based on assignment and user role
      status: (() => {
        const finalAssignedTo =
          assignedTo ||
          (req.user.role === "advocate" && !assignedTo
            ? req.user._id
            : undefined);

        console.log("=== DEBUG: Status Assignment ===");
        console.log("User Role:", req.user.role);
        console.log("AssignedTo from request:", assignedTo);
        console.log("Final AssignedTo:", finalAssignedTo);
        console.log("Is Advocate:", req.user.role === "advocate");

        let status;
        if (req.user.role === "legal_head") {
          status = finalAssignedTo ? "assigned" : "filed";
        } else if (req.user.role === "advocate") {
          status = finalAssignedTo ? "assigned" : "pending_assignment";
        } else {
          // For admins and other roles, check if case is assigned
          status = finalAssignedTo ? "assigned" : "pending_assignment";
        }

        console.log("Final Status:", status);
        return status;
      })(),
    });

    // Handle escalation from credit collection
    if (escalatedFromCreditCase) {
      const creditCase = await CreditCase.findById(escalatedFromCreditCase).populate('documents');
      if (creditCase) {
        // Check if case is already escalated - but allow assignment if it's already escalated
        if (
          creditCase.escalatedToLegal ||
          creditCase.status === "escalated_to_legal"
        ) {
          // If case is already escalated, we're just assigning it to an advocate
          // Don't create a new escalation, just use the existing escalation data
          newCase.escalatedFrom = {
            creditCaseId: creditCase._id,
            escalationDate: creditCase.escalationDate || new Date(),
          };
          
          // If there's already a legal case ID, we're just reassigning
          if (creditCase.legalCaseId) {
            console.log("Case already has legal case ID:", creditCase.legalCaseId);
          }
        } else {
          // Case is not escalated yet, create new escalation
          newCase.escalatedFrom = {
            creditCaseId: creditCase._id,
            escalationDate: new Date(),
          };
          
          // Transfer all relevant information from credit case to legal case
          console.log("=== DEBUG: Transferring Credit Case Data ===");
          console.log("Credit Case Data:", {
            caseNumber: creditCase.caseNumber,
            title: creditCase.title,
            debtorName: creditCase.debtorName,
            debtorEmail: creditCase.debtorEmail,
            debtorContact: creditCase.debtorContact,
            creditorName: creditCase.creditorName,
            creditorEmail: creditCase.creditorEmail,
            creditorContact: creditCase.creditorContact,
            debtAmount: creditCase.debtAmount,
            currency: creditCase.currency,
            documents: creditCase.documents?.length || 0,
            notes: creditCase.notes?.length || 0,
            promisedPayments: creditCase.promisedPayments?.length || 0
          });
          
          // Transfer documents from credit case
          if (creditCase.documents && creditCase.documents.length > 0) {
            const transferredDocuments = creditCase.documents.map(doc => ({
              name: doc.name || doc.originalName || 'Document',
              originalName: doc.originalName || doc.name || 'Document',
              path: doc.path,
              size: doc.size || 0,
              mimeType: doc.mimeType || 'application/octet-stream',
              uploadedBy: doc.uploadedBy || req.user._id,
              uploadedAt: doc.uploadedAt || new Date(),
            }));
            
            // Add transferred documents to the new legal case
            newCase.documents = [...(newCase.documents || []), ...transferredDocuments];
            console.log(`Transferred ${transferredDocuments.length} documents from credit case`);
          }
          
          // Transfer case details if not already provided
          if (!newCase.title && creditCase.title) {
            newCase.title = `Legal Case - ${creditCase.title}`;
          }
          
          if (!newCase.description && creditCase.description) {
            newCase.description = `Escalated from credit collection case ${creditCase.caseNumber}: ${creditCase.description}`;
          }
          
          // Transfer debtor information as client if not already provided
          if (!newCase.client && creditCase.client) {
            // Use existing client from credit case
            newCase.client = creditCase.client;
            console.log("Transferred existing client from credit case");
          } else if (!newCase.client && (creditCase.debtorName || creditCase.debtorEmail)) {
            // Create client from debtor information if no client exists
            const debtorClient = {
              name: creditCase.debtorName || '',
              email: creditCase.debtorEmail || '',
              phone: creditCase.debtorContact || '',
            };
            
            // Check if client already exists
            let existingClient = await Client.findOne({
              email: debtorClient.email,
              lawFirm: req.user.lawFirm._id,
            });
            
            if (existingClient) {
              newCase.client = existingClient._id;
              console.log("Found existing client for debtor");
            } else if (debtorClient.email) {
              // Create new client from debtor
              const [firstName, ...lastNameParts] = debtorClient.name.trim().split(" ");
              const lastName = lastNameParts.join(" ") || "Client";
              
              const newClient = new Client({
                firstName: firstName || "Client",
                lastName: lastName,
                email: debtorClient.email,
                phoneNumber: debtorClient.phone || "",
                lawFirm: req.user.lawFirm._id,
                createdBy: req.user._id,
              });
              
              const savedClient = await newClient.save();
              newCase.client = savedClient._id;
              console.log("Created client from debtor information");
            }
          }
          
          // Transfer creditor information as opposing party if not already provided
          if (!newCase.opposingParty && (creditCase.creditorName || creditCase.creditorEmail)) {
            newCase.opposingParty = {
              name: creditCase.creditorName || '',
              contact: {
                email: creditCase.creditorEmail || '',
                phone: creditCase.creditorContact || '',
              },
            };
            console.log("Transferred creditor information as opposing party");
          }
          
          // Transfer debt amount and escalation fee information
          if (!newCase.filingFee) {
            const filingFeeAmount = creditCase.escalationPayment?.amount || creditCase.debtAmount || 5000;
            newCase.filingFee = {
              amount: filingFeeAmount,
              currency: creditCase.currency || "KES",
              paid: creditCase.escalationPayment?.status === "confirmed" || false,
              paidAt: creditCase.escalationPayment?.confirmedAt || null,
            };
            console.log(`Transferred filing fee: ${filingFeeAmount} ${creditCase.currency || 'KES'}`);
          }
          
          // Transfer case reference
          if (!newCase.caseReference && creditCase.caseNumber) {
            newCase.caseReference = creditCase.caseNumber;
          }
          
          // Transfer case type and priority
          if (!newCase.caseType) {
            newCase.caseType = "debt_collection";
          }
          
          if (!newCase.priority && creditCase.priority) {
            newCase.priority = creditCase.priority;
          }
          
          // Transfer notes from credit case as internal notes
          if (creditCase.notes && creditCase.notes.length > 0) {
            const transferredNotes = creditCase.notes.map(note => ({
              content: `[Transferred from Credit Collection] ${note.content}`,
              createdBy: note.createdBy,
              isInternal: true,
              createdAt: note.createdAt || new Date(),
            }));
            
            newCase.notes = [...(newCase.notes || []), ...transferredNotes];
            console.log(`Transferred ${transferredNotes.length} notes from credit case`);
          }
          
          // Transfer promised payments information as case notes
          if (creditCase.promisedPayments && creditCase.promisedPayments.length > 0) {
            const paymentNotes = creditCase.promisedPayments.map(payment => ({
              content: `Promised Payment: ${payment.amount} ${payment.currency} on ${new Date(payment.promisedDate).toLocaleDateString()}. Status: ${payment.status}${payment.notes ? `. Notes: ${payment.notes}` : ''}`,
              createdBy: payment.createdBy,
              isInternal: true,
              createdAt: payment.createdAt || new Date(),
            }));
            
            newCase.notes = [...(newCase.notes || []), ...paymentNotes];
            console.log(`Transferred ${paymentNotes.length} payment records as notes`);
          }
          
          // Set escalation fee in escalatedFrom
          if (creditCase.escalationPayment?.amount) {
            newCase.escalatedFrom.escalationFee = creditCase.escalationPayment.amount;
          }
          
          console.log("=== DEBUG: Data Transfer Complete ===");
        }
      }
    }

    console.log("=== DEBUG: About to save legal case ===");
    console.log("New case data before save:");
    console.log("- Title:", newCase.title);
    console.log("- Description:", newCase.description);
    console.log("- Client:", newCase.client);
    console.log("- Opposing Party:", newCase.opposingParty);
    console.log("- Filing Fee:", newCase.filingFee);
    console.log("- Documents:", newCase.documents?.length || 0);
    console.log("- Notes:", newCase.notes?.length || 0);
    console.log("- Escalated From:", newCase.escalatedFrom);
    
    const savedCase = await newCase.save();
    
    console.log("=== DEBUG: Legal case saved ===");
    console.log("Saved case ID:", savedCase._id);
    console.log("Client:", savedCase.client);
    console.log("Opposing party:", savedCase.opposingParty);
    console.log("Filing fee:", savedCase.filingFee);
    console.log("Documents count:", savedCase.documents?.length || 0);
    console.log("Notes count:", savedCase.notes?.length || 0);

    // Update credit case with legal case ID after saving
    if (escalatedFromCreditCase) {
      try {
        const creditCase = await CreditCase.findById(escalatedFromCreditCase);
        if (creditCase) {
          // Only update if not already escalated
          if (!creditCase.escalatedToLegal && creditCase.status !== "escalated_to_legal") {
            await CreditCase.findByIdAndUpdate(
              escalatedFromCreditCase,
              {
                status: "escalated_to_legal",
                escalatedToLegal: true,
                legalCaseId: savedCase._id,
                processed: true,
                lastActivity: new Date(),
              },
              { new: true }
            );

            console.log("=== DEBUG: Credit Case Updated ===");
            console.log("Credit Case ID:", creditCase._id);
            console.log("Legal Case ID:", savedCase._id);
            console.log("Status: escalated_to_legal");
          } else {
            // Case is already escalated, just update the legal case ID if needed
            if (!creditCase.legalCaseId) {
              await CreditCase.findByIdAndUpdate(
                escalatedFromCreditCase,
                {
                  legalCaseId: savedCase._id,
                  lastActivity: new Date(),
                },
                { new: true }
              );
              console.log("=== DEBUG: Updated existing escalated case with legal case ID ===");
            } else {
              console.log("=== DEBUG: Case already escalated and has legal case ID ===");
            }
          }
        }
      } catch (error) {
        console.error("Error updating credit case:", error);
        // Continue with legal case creation even if credit case update fails
      }
    }

    console.log("=== DEBUG: Case Created ===");
    console.log("Saved Case ID:", savedCase._id);
    console.log("Case Number:", savedCase.caseNumber);
    console.log("Assigned To:", savedCase.assignedTo);

    // Create notification if advocate auto-assigned the case to themselves (only when no explicit assignment)
    if (req.user.role === "advocate" && !assignedTo) {
      await createNotification({
        user: req.user._id,
        title: `Case Created and Assigned: ${savedCase.caseNumber}`,
        message: `You have created and been assigned case "${savedCase.title}". You can now start working on it.`,
        type: "case_assigned",
        priority: "medium",
        relatedCase: savedCase._id,
        actionUrl: `/legal/cases/${savedCase._id}`,
        metadata: {
          caseNumber: savedCase.caseNumber,
          caseTitle: savedCase.title,
          autoAssigned: true,
        },
      });
    }

    // Create notification if case is assigned to someone else
    if (
      savedCase.assignedTo &&
      savedCase.assignedTo.toString() !== req.user._id.toString()
    ) {
      await createNotification({
        user: savedCase.assignedTo,
        title: `Case Assigned: ${savedCase.caseNumber}`,
        message: `You have been assigned case "${savedCase.title}" by ${req.user.firstName} ${req.user.lastName}.`,
        type: "case_assigned",
        priority: "high",
        relatedCase: savedCase._id,
        actionUrl: `/legal/cases/${savedCase._id}`,
        metadata: {
          caseNumber: savedCase.caseNumber,
          caseTitle: savedCase.title,
          assignedBy: `${req.user.firstName} ${req.user.lastName}`,
        },
        sendEmail: true, // Enable email notification
      });
    }

    // Emit socket event for real-time updates
    req.app.get("io").emit("legalCaseCreated", savedCase);

    res.status(201).json({
      success: true,
      data: savedCase,
      message: "Legal case created successfully",
    });
  } catch (error) {
    console.error("Error in createLegalCase:", error);
    res.status(500).json({
      success: false,
      message: "Server error creating legal case",
      error: error.message,
    });
  }
};

/**
 * @desc    Get all legal cases with filtering and pagination
 * @route   GET /api/legal-cases
 * @access  Private (legal_head, advocate)
 */
export const getLegalCases = async (req, res) => {
  try {
    const {
      page = 1,
      limit = 10,
      status,
      caseType,
      priority,
      assignedTo,
      search,
      escalatedFrom,
    } = req.query;

    // Check if user has law firm association
    if (!req.user.lawFirm) {
      console.error("User has no law firm association:", req.user._id);
      return res.status(400).json({
        success: false,
        message: "User is not associated with any law firm",
      });
    }

    let filter = { lawFirm: req.user.lawFirm._id || req.user.lawFirm };

    // Role-based filtering
    if (req.user.role === "advocate") {
      filter.assignedTo = req.user._id;
    }

    // Apply filters
    if (status) filter.status = status;
    if (caseType) filter.caseType = caseType;
    if (priority) filter.priority = priority;
    if (assignedTo) filter.assignedTo = assignedTo;
    if (escalatedFrom === "true") {
      filter["escalatedFrom.creditCaseId"] = { $exists: true };
    }

    // Search functionality
    if (search) {
      filter.$or = [
        { title: { $regex: search, $options: "i" } },
        { caseNumber: { $regex: search, $options: "i" } },
        { description: { $regex: search, $options: "i" } },
      ];
    }

    const skip = (page - 1) * limit;

    const cases = await LegalCase.find(filter)
      .populate("client", "firstName lastName email")
      .populate("assignedTo", "firstName lastName email")
      .populate("assignedBy", "firstName lastName email")
      .populate("createdBy", "firstName lastName email")
      .populate("department", "name code")
      .populate("escalatedFrom.creditCaseId", "caseNumber title")
      .sort({ createdAt: -1 })
      .skip(skip)
      .limit(parseInt(limit));

    const total = await LegalCase.countDocuments(filter);

    res.json({
      success: true,
      data: cases,
      pagination: {
        currentPage: parseInt(page),
        totalPages: Math.ceil(total / limit),
        totalCount: total,
        limit: parseInt(limit),
      },
    });
  } catch (error) {
    console.error("Error in getLegalCases:", error);
    res.status(500).json({
      success: false,
      message: "Server error fetching legal cases",
      error: error.message,
    });
  }
};

/**
 * @desc    Get a single legal case by ID
 * @route   GET /api/legal-cases/:id
 * @access  Private (legal_head, advocate)
 */
export const getLegalCaseById = async (req, res) => {
  try {
    const { id } = req.params;

    const legalCase = await LegalCase.findById(id)
      .populate("client", "firstName lastName email phoneNumber address")
      .populate("assignedTo", "firstName lastName email phoneNumber")
      .populate("assignedBy", "firstName lastName email")
      .populate("createdBy", "firstName lastName email")
      .populate("department", "name code")
      .populate({
        path: "escalatedFrom.creditCaseId",
        select: "caseNumber title description debtorName debtorEmail debtorContact creditorName creditorEmail creditorContact debtAmount currency documents notes promisedPayments escalationPayment"
      })
      .populate("documents.uploadedBy", "firstName lastName");

    if (!legalCase) {
      return res.status(404).json({
        success: false,
        message: "Legal case not found",
      });
    }

    // Debug logging for escalated cases
    if (legalCase.escalatedFrom && legalCase.escalatedFrom.creditCaseId) {
      console.log("=== DEBUG: Escalated Case Data ===");
      console.log("Legal Case ID:", legalCase._id);
      console.log("Escalated From:", legalCase.escalatedFrom);
      console.log("Credit Case Data:", legalCase.escalatedFrom.creditCaseId);
      console.log("Client Data:", legalCase.client);
      console.log("Opposing Party:", legalCase.opposingParty);
      console.log("Documents Count:", legalCase.documents?.length || 0);
      console.log("Notes Count:", legalCase.notes?.length || 0);
    }

    // Check if user has access to this case
    if (
      req.user.role === "advocate" &&
      legalCase.assignedTo?._id.toString() !== req.user._id.toString()
    ) {
      return res.status(403).json({
        success: false,
        message: "You don't have access to this case",
      });
    }

    res.json({
      success: true,
      data: legalCase,
    });
  } catch (error) {
    console.error("Error in getLegalCaseById:", error);
    res.status(500).json({
      success: false,
      message: "Server error fetching legal case",
      error: error.message,
    });
  }
};

/**
 * @desc    Assign a legal case to an advocate
 * @route   PUT /api/legal-cases/:id/assign
 * @access  Private (legal_head)
 */
export const assignLegalCase = async (req, res) => {
  try {
    const { id } = req.params;
    const { assignedTo, notes } = req.body;

    console.log("=== DEBUG: assignLegalCase ===");
    console.log("Case ID:", id);
    console.log("Assigned To:", assignedTo);
    console.log("Notes:", notes);

    // Only legal head and law firm admin can assign cases
    if (!["legal_head", "law_firm_admin", "admin"].includes(req.user.role)) {
      return res.status(403).json({
        success: false,
        message: "Only legal head and law firm admin can assign cases",
      });
    }

    const legalCase = await LegalCase.findById(id);
    if (!legalCase) {
      return res.status(404).json({
        success: false,
        message: "Legal case not found",
      });
    }

    // Verify the case belongs to the user's law firm
    if (legalCase.lawFirm.toString() !== req.user.lawFirm._id.toString()) {
      return res.status(403).json({
        success: false,
        message: "You can only assign cases from your law firm",
      });
    }

    // Verify the assigned user is an advocate, legal head, or admin (for self-assignment)
    const assignedUser = await User.findById(assignedTo);
    if (
      !assignedUser ||
      !["advocate", "legal_head", "law_firm_admin", "admin"].includes(
        assignedUser.role
      )
    ) {
      return res.status(400).json({
        success: false,
        message: "Assigned user must be an advocate, legal head, or admin",
      });
    }

    // Check if required documents are uploaded for escalated cases
    if (legalCase.escalatedFrom?.creditCaseId) {
      const requiredDocs = [
        "demand_letter",
        "payment_proof",
        "debtor_response",
        "escalation_authorization",
      ];
      const uploadedDocs = legalCase.documents.map((doc) => doc.name);
      const missingDocs = requiredDocs.filter(
        (doc) => !uploadedDocs.includes(doc)
      );

      if (missingDocs.length > 0) {
        return res.status(400).json({
          success: false,
          message: `Missing required documents: ${missingDocs.join(", ")}`,
          missingDocuments: missingDocs,
        });
      }
    }

    legalCase.assignedTo = assignedTo;
    legalCase.assignedBy = req.user._id;
    legalCase.assignedAt = new Date();
    legalCase.status = "assigned";

    if (notes) {
      legalCase.notes.push({
        content: notes,
        createdBy: req.user._id,
        isInternal: true,
      });
    }

    const updatedCase = await legalCase.save();

    // Create notification for the assigned advocate
    await createNotification({
      user: assignedTo,
      title: `Case Assigned: ${legalCase.caseNumber}`,
      message: `You have been assigned case "${legalCase.title}" by ${req.user.firstName} ${req.user.lastName}.`,
      type: "case_assigned",
      priority: "high",
      relatedCase: legalCase._id,
      actionUrl: `/legal/cases/${legalCase._id}`,
      metadata: {
        caseNumber: legalCase.caseNumber,
        caseTitle: legalCase.title,
        assignedBy: `${req.user.firstName} ${req.user.lastName}`,
      },
      sendEmail: true, // Enable email notification
    });

    // Emit socket event
    req.app.get("io").emit("legalCaseAssigned", updatedCase);

    res.json({
      success: true,
      data: updatedCase,
      message: "Case assigned successfully",
    });
  } catch (error) {
    console.error("Error in assignLegalCase:", error);
    res.status(500).json({
      success: false,
      message: "Server error assigning case",
      error: error.message,
    });
  }
};

/**
 * @desc    Update legal case status
 * @route   PUT /api/legal-cases/:id/status
 * @access  Private (legal_head, advocate)
 */
export const updateLegalCaseStatus = async (req, res) => {
  try {
    const { id } = req.params;
    const { status, notes } = req.body;

    const legalCase = await LegalCase.findById(id);
    if (!legalCase) {
      return res.status(404).json({
        success: false,
        message: "Legal case not found",
      });
    }

    // Verify the case belongs to the user's law firm
    if (legalCase.lawFirm.toString() !== req.user.lawFirm._id.toString()) {
      return res.status(403).json({
        success: false,
        message: "You can only modify cases from your law firm",
      });
    }

    // Check permissions - admins can update any case, advocates can only update their assigned cases
    if (
      req.user.role === "advocate" &&
      legalCase.assignedTo?.toString() !== req.user._id.toString()
    ) {
      return res.status(403).json({
        success: false,
        message: "You can only update cases assigned to you",
      });
    }

    // Allow legal heads and admins to update any case
    if (
      !["advocate", "legal_head", "law_firm_admin", "admin"].includes(
        req.user.role
      )
    ) {
      return res.status(403).json({
        success: false,
        message: "You don't have permission to update case status",
      });
    }

    legalCase.status = status;
    legalCase.lastActivity = new Date();

    if (notes) {
      legalCase.notes.push({
        content: notes,
        createdBy: req.user._id,
        isInternal: false,
      });
    }

    const updatedCase = await legalCase.save();

    // Emit socket event
    req.app.get("io").emit("legalCaseStatusUpdated", updatedCase);

    res.json({
      success: true,
      data: updatedCase,
      message: "Case status updated successfully",
    });
  } catch (error) {
    console.error("Error in updateLegalCaseStatus:", error);
    res.status(500).json({
      success: false,
      message: "Server error updating case status",
      error: error.message,
    });
  }
};

/**
 * @desc    Add document to legal case
 * @route   POST /api/legal-cases/:id/documents
 * @access  Private (legal_head, advocate)
 */
export const addDocumentToCase = async (req, res) => {
  try {
    const { id } = req.params;
    const { documents } = req.body;

    console.log("=== DEBUG: addDocumentToCase ===");
    console.log("Request body:", req.body);
    console.log("Documents:", documents);
    console.log("Documents type:", typeof documents);
    console.log("Is Array:", Array.isArray(documents));

    const legalCase = await LegalCase.findById(id);
    if (!legalCase) {
      return res.status(404).json({
        success: false,
        message: "Legal case not found",
      });
    }

    // Verify the case belongs to the user's law firm
    if (legalCase.lawFirm.toString() !== req.user.lawFirm._id.toString()) {
      return res.status(403).json({
        success: false,
        message: "You can only add documents to cases from your law firm",
      });
    }

    // Check permissions
    if (
      req.user.role === "advocate" &&
      legalCase.assignedTo?.toString() !== req.user._id.toString()
    ) {
      return res.status(403).json({
        success: false,
        message: "You can only add documents to cases assigned to you",
      });
    }

    // Validate documents parameter
    if (!documents) {
      return res.status(400).json({
        success: false,
        message: "Documents parameter is required",
      });
    }

    // Ensure documents is an array
    const documentsArray = Array.isArray(documents) ? documents : [documents];

    console.log("Documents array:", documentsArray);

    // Process documents - handle both Cloudinary URLs and file objects
    const processedDocuments = documentsArray.map((doc) => {
      if (typeof doc === "string") {
        // If it's a Cloudinary URL, create a document object
        const filename = doc.split("/").pop().split("?")[0] || "Document";
        return {
          name: filename,
          originalName: filename,
          path: doc, // Cloudinary URL
          size: 0, // Size not available for Cloudinary URLs
          mimeType: "application/octet-stream",
          uploadedBy: req.user._id,
        };
      } else if (doc && typeof doc === "object" && doc.documents) {
        // Handle nested documents structure
        return doc.documents.map((nestedDoc) => {
          if (typeof nestedDoc === "string") {
            const filename =
              nestedDoc.split("/").pop().split("?")[0] || "Document";
            return {
              name: filename,
              originalName: filename,
              path: nestedDoc,
              size: 0,
              mimeType: "application/octet-stream",
              uploadedBy: req.user._id,
            };
          } else {
            return {
              ...nestedDoc,
              uploadedBy: req.user._id,
            };
          }
        });
      } else {
        // If it's already a document object
        return {
          ...doc,
          uploadedBy: req.user._id,
        };
      }
    });

    // Flatten the processed documents array
    const flattenedDocuments = processedDocuments.flat();

    // Add documents to case
    legalCase.documents.push(...flattenedDocuments);

    const updatedCase = await legalCase.save();

    res.json({
      success: true,
      data: updatedCase,
      message: "Documents added successfully",
    });
  } catch (error) {
    console.error("Error in addDocumentToCase:", error);
    res.status(500).json({
      success: false,
      message: "Server error adding documents",
      error: error.message,
    });
  }
};

/**
 * @desc    Add note to legal case
 * @route   POST /api/legal-cases/:id/notes
 * @access  Private (legal_head, advocate)
 */
export const addNoteToCase = async (req, res) => {
  try {
    const { id } = req.params;
    const { content, isInternal = false } = req.body;

    const legalCase = await LegalCase.findById(id);
    if (!legalCase) {
      return res.status(404).json({
        success: false,
        message: "Legal case not found",
      });
    }

    // Check permissions
    if (
      req.user.role === "advocate" &&
      legalCase.assignedTo?.toString() !== req.user._id.toString()
    ) {
      return res.status(403).json({
        success: false,
        message: "You can only add notes to cases assigned to you",
      });
    }

    legalCase.notes.push({
      content,
      createdBy: req.user._id,
      isInternal,
    });

    const updatedCase = await legalCase.save();

    // Emit socket event for real-time updates
    const io = req.app.get("io");
    if (io) {
      const newNote = updatedCase.notes[updatedCase.notes.length - 1];
      io.to(`case-${id}`).emit("legalCaseCommented", {
        _id: newNote._id,
        content: newNote.content,
        author: req.user,
        createdAt: newNote.createdAt,
        type: 'comment',
        isInternal: newNote.isInternal
      });
    }

    res.json({
      success: true,
      data: updatedCase,
      message: "Note added successfully",
    });
  } catch (error) {
    console.error("Error in addNoteToCase:", error);
    res.status(500).json({
      success: false,
      message: "Server error adding note",
      error: error.message,
    });
  }
};

/**
 * @desc    Get cases pending assignment (for legal head)
 * @route   GET /api/legal-cases/pending-assignment
 * @access  Private (legal_head)
 */
export const getPendingAssignmentCases = async (req, res) => {
  try {
    if (req.user.role !== "legal_head" && req.user.role !== "law_firm_admin") {
      return res.status(403).json({
        success: false,
        message:
          "Only legal head and law firm admin can view pending assignment cases",
      });
    }

    const cases = await LegalCase.find({
      lawFirm: req.user.lawFirm._id,
      status: "pending_assignment",
    })
      .populate("client", "firstName lastName email")
      .populate("createdBy", "firstName lastName email")
      .populate("escalatedFrom.creditCaseId", "caseNumber title")
      .sort({ createdAt: -1 });

    res.json({
      success: true,
      data: cases,
    });
  } catch (error) {
    console.error("Error in getPendingAssignmentCases:", error);
    res.status(500).json({
      success: false,
      message: "Server error fetching pending cases",
      error: error.message,
    });
  }
};

/**
 * @desc    Get assigned cases for advocate
 * @route   GET /api/legal-cases/assigned/:userId
 * @access  Private (advocate, legal_head)
 */
export const getAssignedCases = async (req, res) => {
  try {
    const { userId } = req.params;

    // Check permissions
    if (req.user.role === "advocate" && req.user._id.toString() !== userId) {
      return res.status(403).json({
        success: false,
        message: "You can only view your own assigned cases",
      });
    }

    const cases = await LegalCase.find({
      lawFirm: req.user.lawFirm._id,
      assignedTo: userId,
    })
      .populate("client", "firstName lastName email")
      .populate("escalatedFrom.creditCaseId", "caseNumber title")
      .sort({ lastActivity: -1 });

    res.json({
      success: true,
      data: cases,
    });
  } catch (error) {
    console.error("Error in getAssignedCases:", error);
    res.status(500).json({
      success: false,
      message: "Server error fetching assigned cases",
      error: error.message,
    });
  }
};

/**
 * @desc    Update court dates for legal case
 * @route   PUT /api/legal-cases/:id/court-dates
 * @access  Private (advocate, legal_head)
 */
export const updateCourtDates = async (req, res) => {
  try {
    const { id } = req.params;
    const {
      nextHearingDate,
      mentioningDate,
      hearingNotes,
      adjournmentReason,
      courtDate,
      courtRoom,
      judgeAssigned,
    } = req.body;

    const legalCase = await LegalCase.findById(id);
    if (!legalCase) {
      return res.status(404).json({
        success: false,
        message: "Legal case not found",
      });
    }

    // Check permissions
    if (
      req.user.role === "advocate" &&
      legalCase.assignedTo?.toString() !== req.user._id.toString()
    ) {
      return res.status(403).json({
        success: false,
        message: "You can only update court dates for cases assigned to you",
      });
    }

    // Update court details
    if (nextHearingDate) {
      legalCase.courtDetails.nextHearingDate = new Date(nextHearingDate);
    }
    if (mentioningDate) {
      legalCase.courtDetails.mentioningDate = new Date(mentioningDate);
    }
    if (courtDate) {
      legalCase.courtDetails.courtDate = new Date(courtDate);
    }
    if (courtRoom) {
      legalCase.courtDetails.courtRoom = courtRoom;
    }
    if (judgeAssigned) {
      legalCase.courtDetails.judgeAssigned = judgeAssigned;
    }
    if (hearingNotes) {
      legalCase.courtDetails.hearingNotes = hearingNotes;
    }
    if (adjournmentReason) {
      legalCase.courtDetails.adjournmentReason = adjournmentReason;
    }

    const updatedCase = await legalCase.save();

    // Create notifications for upcoming court dates
    if (nextHearingDate) {
      const hearingDate = new Date(nextHearingDate);
      const today = new Date();
      const daysUntil = Math.ceil(
        (hearingDate - today) / (1000 * 60 * 60 * 24)
      );

      if (daysUntil <= 7) {
        await createNotification({
          user: legalCase.assignedTo,
          title: `Upcoming Hearing: ${legalCase.caseNumber}`,
          message: `Hearing for case "${
            legalCase.title
          }" is in ${daysUntil} day${
            daysUntil !== 1 ? "s" : ""
          }. Date: ${hearingDate.toLocaleDateString()}`,
          type: "hearing_date",
          priority:
            daysUntil <= 1 ? "urgent" : daysUntil <= 3 ? "high" : "medium",
          relatedCase: legalCase._id,
          eventDate: hearingDate,
          actionUrl: `/legal/cases/${legalCase._id}`,
          metadata: {
            caseNumber: legalCase.caseNumber,
            caseTitle: legalCase.title,
            daysUntil,
            courtName: legalCase.courtDetails?.courtName,
          },
        });
      }
    }

    if (mentioningDate) {
      const mentioning = new Date(mentioningDate);
      const today = new Date();
      const daysUntil = Math.ceil((mentioning - today) / (1000 * 60 * 60 * 24));

      if (daysUntil <= 7) {
        await createNotification({
          user: legalCase.assignedTo,
          title: `Upcoming Mentioning: ${legalCase.caseNumber}`,
          message: `Mentioning for case "${
            legalCase.title
          }" is in ${daysUntil} day${
            daysUntil !== 1 ? "s" : ""
          }. Date: ${mentioning.toLocaleDateString()}`,
          type: "mentioning_date",
          priority:
            daysUntil <= 1 ? "urgent" : daysUntil <= 3 ? "high" : "medium",
          relatedCase: legalCase._id,
          eventDate: mentioning,
          actionUrl: `/legal/cases/${legalCase._id}`,
          metadata: {
            caseNumber: legalCase.caseNumber,
            caseTitle: legalCase.title,
            daysUntil,
            courtName: legalCase.courtDetails?.courtName,
          },
        });
      }
    }

    res.json({
      success: true,
      data: updatedCase,
      message: "Court dates updated successfully",
    });
  } catch (error) {
    console.error("Error in updateCourtDates:", error);
    res.status(500).json({
      success: false,
      message: "Server error updating court dates",
      error: error.message,
    });
  }
};

/**
 * @desc    Update legal case
 * @route   PUT /api/legal-cases/:id
 * @access  Private (advocate, legal_head)
 */
export const updateLegalCase = async (req, res) => {
  try {
    const { id } = req.params;
    const updateData = req.body;

    const legalCase = await LegalCase.findById(id);
    if (!legalCase) {
      return res.status(404).json({
        success: false,
        message: "Legal case not found",
      });
    }

    // Check permissions
    if (
      req.user.role === "advocate" &&
      legalCase.assignedTo?.toString() !== req.user._id.toString()
    ) {
      return res.status(403).json({
        success: false,
        message: "You can only update cases assigned to you",
      });
    }

    // Handle documents if provided
    if (updateData.documents && Array.isArray(updateData.documents)) {
      const processedDocuments = updateData.documents.map((doc) => {
        if (typeof doc === "string") {
          // If it's a Cloudinary URL, create a document object
          const filename = doc.split("/").pop().split("?")[0] || "Document";
          return {
            name: filename,
            originalName: filename,
            path: doc, // Cloudinary URL
            size: 0, // Size not available for Cloudinary URLs
            mimeType: "application/octet-stream",
            uploadedBy: req.user._id,
          };
        } else {
          // If it's already a document object
          return {
            ...doc,
            uploadedBy: req.user._id,
          };
        }
      });

      legalCase.documents.push(...processedDocuments);
      delete updateData.documents; // Remove from updateData since we handled it
    }

    // Update the case with the provided data
    Object.keys(updateData).forEach((key) => {
      if (key === "courtDetails" && updateData[key]) {
        legalCase.courtDetails = {
          ...legalCase.courtDetails,
          ...updateData[key],
        };
      } else if (key === "opposingParty" && updateData[key]) {
        legalCase.opposingParty = {
          ...legalCase.opposingParty,
          ...updateData[key],
        };
      } else if (key !== "documents") {
        legalCase[key] = updateData[key];
      }
    });

    legalCase.lastActivity = new Date();
    const updatedCase = await legalCase.save();

    // Emit socket event
    req.app.get("io").emit("legalCaseUpdated", updatedCase);

    res.json({
      success: true,
      data: updatedCase,
      message: "Legal case updated successfully",
    });
  } catch (error) {
    console.error("Error in updateLegalCase:", error);
    res.status(500).json({
      success: false,
      message: "Server error updating legal case",
      error: error.message,
    });
  }
};

/**
 * @desc    Get legal case statistics
 * @route   GET /api/legal-cases/statistics
 * @access  Private (legal_head, advocate)
 */
export const getLegalCaseStatistics = async (req, res) => {
  try {
    const { period = "30" } = req.query;
    const daysAgo = new Date();
    daysAgo.setDate(daysAgo.getDate() - parseInt(period));

    let filter = {
      lawFirm: req.user.lawFirm._id,
      createdAt: { $gte: daysAgo },
    };

    // Role-based filtering
    if (req.user.role === "advocate") {
      filter.assignedTo = req.user._id;
    }

    const stats = await LegalCase.aggregate([
      { $match: filter },
      {
        $group: {
          _id: "$status",
          count: { $sum: 1 },
          totalFilingFees: { $sum: "$filingFee.amount" },
        },
      },
    ]);

    const totalCases = await LegalCase.countDocuments(filter);
    const escalatedCases = await LegalCase.countDocuments({
      ...filter,
      "escalatedFrom.creditCaseId": { $exists: true },
    });

    res.json({
      success: true,
      data: {
        statusBreakdown: stats,
        totalCases,
        escalatedCases,
        period: parseInt(period),
      },
    });
  } catch (error) {
    console.error("Error in getLegalCaseStatistics:", error);
    res.status(500).json({
      success: false,
      message: "Server error fetching statistics",
      error: error.message,
    });
  }
};

/**
 * @desc    Complete case information (for advocates to add missing details)
 * @route   PUT /api/legal-cases/:id/complete-info
 * @access  Private (advocate assigned to case)
 */
export const completeCaseInfo = async (req, res) => {
  try {
    const { id } = req.params;
    const { client, courtDetails, opposingParty, filingFee } = req.body;

    // Check if case exists and user has permission
    const existingCase = await LegalCase.findById(id)
      .populate("assignedTo", "firstName lastName email")
      .populate("client", "firstName lastName email phoneNumber clientType companyName");

    if (!existingCase) {
      return res.status(404).json({
        success: false,
        message: "Legal case not found",
      });
    }

    // Check if user has permission to update this case
    const isAssignedAdvocate = existingCase.assignedTo?._id.toString() === req.user._id.toString();
    const isAdmin = req.user.role === "law_firm_admin" || req.user.role === "law_firm";
    const isLegalHead = req.user.role === "legal_head";
    const isSameLawFirm = existingCase.lawFirm.toString() === req.user.lawFirm._id.toString();

    if (!isSameLawFirm || (!isAssignedAdvocate && !isAdmin && !isLegalHead)) {
      return res.status(403).json({
        success: false,
        message: "You don't have permission to update this case. Only the assigned advocate, legal head, or law firm admin can update case details.",
      });
    }

    // Handle client creation if provided
    let clientId = existingCase.client;
    if (client && typeof client === "object" && client.name && client.email) {
      // Check if client already exists
      let existingClient = await Client.findOne({
        email: client.email,
        lawFirm: req.user.lawFirm._id,
      });

      if (existingClient) {
        clientId = existingClient._id;
      } else {
        // Create new client
        const [firstName, ...lastNameParts] = client.name.trim().split(" ");
        const lastName = lastNameParts.join(" ") || "Client";

        const newClient = new Client({
          firstName: firstName || "Client",
          lastName: lastName,
          email: client.email,
          phoneNumber: client.phone || "",
          lawFirm: req.user.lawFirm._id,
          createdBy: req.user._id,
        });

        const savedClient = await newClient.save();
        clientId = savedClient._id;
      }
    }

    // Prepare update data
    const updateData = {};
    if (clientId) updateData.client = clientId;
    if (courtDetails) updateData.courtDetails = courtDetails;
    if (opposingParty) updateData.opposingParty = opposingParty;
    if (filingFee) updateData.filingFee = filingFee;

    // Update the case
    const updatedCase = await LegalCase.findByIdAndUpdate(
      id,
      { $set: updateData },
      { new: true, runValidators: true }
    )
      .populate("assignedTo", "firstName lastName email")
      .populate("assignedBy", "firstName lastName email")
      .populate("client", "firstName lastName email phoneNumber clientType companyName")
      .populate("createdBy", "firstName lastName email")
      .populate("department", "name code");

    // Create notification for legal head
    await createNotification({
      user: existingCase.assignedBy || req.user.lawFirm.owner, // Notify legal head or firm owner
      title: `Case Information Completed: ${updatedCase.caseNumber}`,
      message: `Advocate ${req.user.firstName} ${req.user.lastName} has completed the information for case "${updatedCase.title}".`,
      type: "case_updated",
      priority: "medium",
      relatedCase: updatedCase._id,
      actionUrl: `/legal/cases/${updatedCase._id}`,
      metadata: {
        caseNumber: updatedCase.caseNumber,
        caseTitle: updatedCase.title,
        completedBy: req.user._id,
      },
    });

    // Emit socket event for real-time updates
    req.app.get("io").emit("legalCaseUpdated", updatedCase);

    res.json({
      success: true,
      data: updatedCase,
      message: "Case information completed successfully",
    });
  } catch (error) {
    console.error("Error in completeCaseInfo:", error);
    res.status(500).json({
      success: false,
      message: "Server error completing case information",
      error: error.message,
    });
  }
};

/**
 * @desc    Update filing fee payment status
 * @route   PATCH /api/legal-cases/:id/filing-fee-payment
 * @access  Private (advocate, legal_head, law_firm_admin)
 */
export const updateFilingFeePayment = async (req, res) => {
  try {
    console.log("=== BACKEND: updateFilingFeePayment called ===");
    const { id } = req.params;
    const { paid, paymentId } = req.body;
    
    console.log("Case ID:", id);
    console.log("Paid:", paid);
    console.log("Payment ID:", paymentId);
    console.log("User:", req.user._id, req.user.role);

    const legalCase = await LegalCase.findById(id);
    if (!legalCase) {
      return res.status(404).json({
        success: false,
        message: "Legal case not found",
      });
    }

    // Check permissions - advocates can only update cases assigned to them
    console.log("Permission check:");
    console.log("- User role:", req.user.role);
    console.log("- Case assigned to:", legalCase.assignedTo?.toString());
    console.log("- User ID:", req.user._id.toString());
    console.log("- IDs match:", legalCase.assignedTo?.toString() === req.user._id.toString());
    
    if (
      req.user.role === "advocate" &&
      legalCase.assignedTo?.toString() !== req.user._id.toString()
    ) {
      console.log("Permission denied - advocate trying to update case not assigned to them");
      return res.status(403).json({
        success: false,
        message: "You can only update payment status for cases assigned to you",
      });
    }

    // Update filing fee payment status
    const updateData = {
      "filingFee.paid": paid,
    };

    if (paid) {
      updateData["filingFee.paidAt"] = new Date();
      if (paymentId) {
        updateData["filingFee.paymentId"] = paymentId;
      }
    } else {
      updateData["filingFee.paidAt"] = null;
      updateData["filingFee.paymentId"] = null;
    }

    console.log("Update data:", updateData);
    
    const updatedCase = await LegalCase.findByIdAndUpdate(
      id,
      { $set: updateData },
      { new: true, runValidators: true }
    )
      .populate("assignedTo", "firstName lastName email")
      .populate("assignedBy", "firstName lastName email")
      .populate("client", "firstName lastName email phoneNumber clientType companyName")
      .populate("createdBy", "firstName lastName email")
      .populate("department", "name code");
      
    console.log("Updated case filing fee:", updatedCase?.filingFee);

    // Create notification for legal head/admin
    await createNotification({
      user: legalCase.assignedBy || req.user.lawFirm.owner,
      title: `Filing Fee Payment ${paid ? 'Confirmed' : 'Updated'}: ${updatedCase.caseNumber}`,
      message: `Advocate ${req.user.firstName} ${req.user.lastName} has ${paid ? 'confirmed' : 'updated'} the filing fee payment status for case "${updatedCase.title}".`,
      type: "payment_update",
      priority: "medium",
      relatedCase: updatedCase._id,
      actionUrl: `/legal/cases/${updatedCase._id}`,
      metadata: {
        caseNumber: updatedCase.caseNumber,
        caseTitle: updatedCase.title,
        paymentStatus: paid,
        updatedBy: req.user._id,
      },
    });

    // Emit socket event for real-time updates
    const io = req.app.get("io");
    if (io) {
      io.to(`case-${id}`).emit("legalCaseUpdated", updatedCase);
    }

    res.json({
      success: true,
      data: updatedCase,
      message: `Filing fee payment status ${paid ? 'confirmed' : 'updated'} successfully`,
    });
  } catch (error) {
    console.error("Error in updateFilingFeePayment:", error);
    res.status(500).json({
      success: false,
      message: "Server error updating payment status",
      error: error.message,
    });
  }
};
